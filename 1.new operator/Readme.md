## new Vs malloc

+ 공통점 
  + 모두 힙메모리에 동적할당을 위해서 사용된다
+ 차이점
  + 생성자 호출
    + 생성과 동시에 초기화가 가능하다
  + new는 operator이고 malloc은 함수이다
  + 리턴타입이 다르다
    + new는 data type을 반환하지만 malloc은 void 포인터를 리턴한다
  + Failure Condition
    + 동적할당에 실패했을때 new는 bad_alloc exception을 발생시키지만 malloc은 NULL을 리턴한다
  + Overriding
    + new operator는 override할 수 있으나 malloc()은 불가능
  + Size
    + new의 경우에 필요한 메모리 크기가 컴파일러에 의해 계산되는 반면 malloc은 사용자가 직접 계산해야 한다
  + Buffer size
    + new는 한 번 생성된 메모리의 크기를 늘릴 수 없으나 mallco은 realloc을 통해 사이즈를 조절할 수 있다.

## 객체지향 프로그래밍 vs 절차적 프로그래밍

+ 절차적 프로그래밍이란 
  + 단순히 순차적인 명령 수행이 아니라 루틴, 서브루틴, 메소드, 함수 등을 이용한 프로그래밍 패러다임을 뜻한다.
  + 이 패러다임에서는 프로시저 콜, 즉 함수 호출을 통해서 추상화와 재사용성을 얻어내는 것이 본질이다
  + 예) C
+ 객체지향 프로그래밍이란
  + 프로그램을 단순히 데이터와 처리 방법으로 나누는 것이 아니라, 프로그램을 수많은 '객체'라는 기본 단위로 나누고 이 객체들의 상호작용으로 서술하는 방식이다. 객체란 하나의 역할을 수행하는 '메소드와 변수(데이터)'의 묶음으로 봐야한다.

## 객체지향 4대요소

+ 클래스와 객체
  + 클래스
    + 같은 특성을 지닌 여러 객체를 총칭하는 집합의 개념
  + 객체
    + unique한 사물,생물
+ 캡슐화
  + 변수와 함수를 하나의 단위로 묶는 것을 의미한다. 
  + 정보은닉
    + 프로그램의 세부 구현을 외부로 드러나지 않도록 특정 모듈 내부로 감추는 것을 의미한다. 클래스를 기준으로 생각하면 클래스 외부에서는 바깥으로 노출된 특정 메소드에만 접근이 가능하며 내부에서 어떤 식으로 처리가 이루어지는지는 알지 못하도록 설계된다.
    + 일반적인 접근 제한자
      + public : 클래스의 외부에서 사용 가능하도록 노출 시키는 것
      + protected : 다른 클래스에게는 노출되지 않지만, 상속받은 자식 클래스에게는 노출되는 것
      + private : 클래스의 내부에서만 사용되며 외부로 노출되지 않는다.
+ 상속
  + 상속은 자식클래스가 부모클래스의 특성과 기능을 그대로 물려받는 것을 말한다. 기능의 일부분을 변경해야 할 경우 자식 클래스에서 상속받은 그 기능만을 수정해서 다시 정의하게 되는데, 이러한 작업을 '오버라이딩(Overriding)'이라고 한다. 상속은 캡슐화를 유지하면서도 재사용이 용이하도록 해 준다.
+ 다형성
  + 하나의 변수, 또는 함수가 상황에 따라 다른 의미로 해석될 수 있는 것을 말한다.
  + 서브타입의 다형성
    + 기초 클래스 또는 인터페이스를 선언한 상위 클래스를 생성하고, 해당 클래스를 상속받는 다수의 하위 클래스들을 만들어 상위 클래스의 포인터나 참조변수 등이 하위 클래스의 객체를 참조하게 하는 것. 이 때, 각각의 하위 클래스는 상위 클래스의 메소드 위에 자신의 메소드를 덮어쓰는 메소드 오버라이딩을 수행하며, 상위 클래스의 참조변수가 어떤 하위 클래스의 객체를 참조하느냐에 따라 호출되는 메소드가 달라진다.
  + 매개변수 다형성
    + 타입을 매겨변수로 받아 새로운 타입을 되돌려주는 기능. 타입 매겨변수를 정의한 클래스 혹은 메소드는 사용할 때 매개변수에 타입을 지정하게 되며, 컴파일 시 지정한 타입에 따라 해석된다
      + template
        + C++에서 사용하는 개념으로, 타입 매개변수를 입력한 타입으로 치환한 코드를 생성하는 방식. 타입뿐 아니라 변수도 입력할 수 있으며, 객체 내부에서 연산이나 함수 호출을 할 수 있지만, 해당 연산이나 함수가 정의되지 않은 타입을 매개변수로 넣으면 컴파일 에러가 발생하며 컴파일이 느려지고 파일이 커진다.
  + 임시 다형성
    + 함수 오버로딩
      + C++ 등에서는 함수 오버로딩을 통해 동일한 이름의 함수를 매개변수에 따라 다른 기능으로 동작하도록 할 수 있다. 
      + 조건으로는
        + 메소드 이름이 같아야하며
        + 매개 변수의 개수 또는 타입이 달라야 하며
        + 리턴타입이 같아야한다
    + 연산자 오버로딩
      + C++ 등에서는 연산자를 오버로딩해서 기본 연산자가 해당 클래스에 맞는 역할을 수행하게 하는 것이 가능하다.
  + 강제 다형성
    + 묵시적 형 변환
      + C++의 변환 생성자에 의한 형 변환(double a = 30 : int->double)은 묵시적 변환에 속하며, 이를 막으려면 생성자 앞에 explicit 키워드를 추가해야 한다

